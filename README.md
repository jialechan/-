## 元编程
```shell
所谓元编程，就是“用程序来编写程序”
```
```shell
程序是由数据结构和算法构成的，然而，如果环境允许程序本身作为数据结构来操作的话，
那么元编程也就是和面向一般数据结构的一般操作没什么两样了
```

## GC
基本gc算法
```shell
标记清除法：从根开始对被引用的对象打上标记，重复这个步骤，把从根开始，被间接引用的对象都打上标记，
执行完之后，没有标记的对象就是没有被引用的对象，这时候再将全部对象按顺序扫描一遍如果没标记的就进行回收。

缺点：如果分配了大量对象，而且只有一小部分存活，所消耗的时间会大大超过必要的值
```
```shell
复制收集方式：开始和标记清除法相识，遍历对象，把有引用的对象复制到新空间，
执行完成后，有引用的对象已经在新空间，可以不遍历一次过把旧空间释放掉。

缺点：需要空间更加多，如果存活的对象很多的话反而比较不利
```
```shell
引用计数方式：在每个对象保存该对象的引用计数，当引用发生增减时对计数进行更新，
如果一个对象的引用计数变为0时，说明它将来不会被引用，所以可以释放掉这个对象

优点：易于实现
缺点：无法释放循环对象；漏掉更新引用数会引起难查的bug；不适合并行处理；
```
改良gc算法
```shell
分代回收：根据大部分对象都会在段时间内成为垃圾，而经过一定时间依然蠢货的对象往往有较长寿命。
按生成时间进行分代，经常扫描新生代（小回收），将存活的保存到老生代，
重复这个步骤，当老生代也满了后，进行大回收
```
```shell
增量回收：由于分代回收还是有大回收可能引起程序中断，所以有了增量回收。
增量回收为了位置程序的实时性，不等gc全部完成，而是将gc操作细分成多个部分逐一执行。
```
```shell
并行回收：利用多核特性在原有的程序运行的同时进行gc操作，这一点和增量回收相似。
```

## 闭包
```javascript
function extent() {
  var n = 0;  //局部变量
  return function() {
    n++;  //对n的访问
    console.log("n=" + n);
  }
}
f = extend(); //返回函数对象
f();  // n = 1
f();  // n = 2
```
```shell
也就是说，这个从属于外部作用域中的局部变量，被函数对象给“封闭”在里面了。
闭包（Closure）这个词原本就是封闭的意思。
被封闭起来的变量的寿命，与封闭它的函数对象寿命相等。
也就是说，当封闭这个变量的函数对象不再被访问，被立即回收器回收掉时，这个变量的寿命也就同时终结了。

对象时再数据中以方法的形式内含了过程；
而闭包则是在过程中以环境的形式内含了数据。
```

## 时间复杂度
```shell
O(1) < O(log n) < O(n) < O(n*log n) < O(n2)

这里的n代表要查找的数据的总量，比如一个表总量是10W。
```

## 二分查找
```shell
前提条件：数据之间有大小关系而且已经按大小关系排序好，利用这个性质查找计算量从O(n)下降到O(log n)。
```

## 散列表
```shell
理想的数据结构就是散列表，理想情况下时间复杂度为O(1)
```

## 布隆过滤器
```shell
布隆过滤器是一种可以判断某个数据是否存在的数据结构，它的特点是：
判断时间与数据个数无关（O(1)）
空间效率非常好
无法删除元素
偶尔会出错 -> 假阳性，就是说不属于这个集合的判断为属于
```
